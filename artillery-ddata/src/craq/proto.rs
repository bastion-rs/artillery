// Autogenerated by Thrift Compiler (0.13.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![cfg_attr(feature = "cargo-clippy", allow(too_many_arguments, type_complexity))]
#![cfg_attr(rustfmt, rustfmt_skip)]

extern crate thrift;

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;
use thrift::OrderedFloat;

use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::protocol::{
    TFieldIdentifier, TInputProtocol, TListIdentifier, TMapIdentifier, TMessageIdentifier,
    TMessageType, TOutputProtocol, TSetIdentifier, TStructIdentifier, TType,
};
use thrift::server::TProcessor;
use thrift::{
    ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient,
};

/// Consistency models.
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum CraqConsistencyModel {
    Strong = 0,
    Eventual = 1,
    EventualMaxBounded = 2,
    Debug = 3,
}

impl CraqConsistencyModel {
    pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
        o_prot.write_i32(*self as i32)
    }
    pub fn read_from_in_protocol(
        i_prot: &mut dyn TInputProtocol,
    ) -> thrift::Result<CraqConsistencyModel> {
        let enum_value = i_prot.read_i32()?;
        CraqConsistencyModel::try_from(enum_value)
    }
}

impl TryFrom<i32> for CraqConsistencyModel {
    type Error = thrift::Error;
    fn try_from(i: i32) -> Result<Self, Self::Error> {
        match i {
            0 => Ok(CraqConsistencyModel::Strong),
            1 => Ok(CraqConsistencyModel::Eventual),
            2 => Ok(CraqConsistencyModel::EventualMaxBounded),
            3 => Ok(CraqConsistencyModel::Debug),
            _ => Err(thrift::Error::Protocol(ProtocolError::new(
                ProtocolErrorKind::InvalidData,
                format!("cannot convert enum constant {} to CraqConsistencyModel", i),
            ))),
        }
    }
}

pub type Version = i64;

//
// CraqObject
//

/// Object envelope.
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CraqObject {
    pub value: Option<Vec<u8>>,
    pub dirty: Option<bool>,
}

impl CraqObject {
    pub fn new<F1, F2>(value: F1, dirty: F2) -> CraqObject
    where
        F1: Into<Option<Vec<u8>>>,
        F2: Into<Option<bool>>,
    {
        CraqObject {
            value: value.into(),
            dirty: dirty.into(),
        }
    }
    pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CraqObject> {
        i_prot.read_struct_begin()?;
        let mut f_1: Option<Vec<u8>> = None;
        let mut f_2: Option<bool> = None;
        loop {
            let field_ident = i_prot.read_field_begin()?;
            if field_ident.field_type == TType::Stop {
                break;
            }
            let field_id = field_id(&field_ident)?;
            match field_id {
                1 => {
                    let val = i_prot.read_bytes()?;
                    f_1 = Some(val);
                }
                2 => {
                    let val = i_prot.read_bool()?;
                    f_2 = Some(val);
                }
                _ => {
                    i_prot.skip(field_ident.field_type)?;
                }
            };
            i_prot.read_field_end()?;
        }
        i_prot.read_struct_end()?;
        let ret = CraqObject {
            value: f_1,
            dirty: f_2,
        };
        Ok(ret)
    }
    pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
        let struct_ident = TStructIdentifier::new("CraqObject");
        o_prot.write_struct_begin(&struct_ident)?;
        if let Some(ref fld_var) = self.value {
            o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 1))?;
            o_prot.write_bytes(fld_var)?;
            o_prot.write_field_end()?;
            ()
        } else {
            ()
        }
        if let Some(fld_var) = self.dirty {
            o_prot.write_field_begin(&TFieldIdentifier::new("dirty", TType::Bool, 2))?;
            o_prot.write_bool(fld_var)?;
            o_prot.write_field_end()?;
            ()
        } else {
            ()
        }
        o_prot.write_field_stop()?;
        o_prot.write_struct_end()
    }
}

impl Default for CraqObject {
    fn default() -> Self {
        CraqObject {
            value: Some(Vec::new()),
            dirty: Some(false),
        }
    }
}

//
// InvalidState
//

/// Artillery CRAQ Invalid State Error
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct InvalidState {
    pub reason: Option<String>,
}

impl InvalidState {
    pub fn new<F1>(reason: F1) -> InvalidState
    where
        F1: Into<Option<String>>,
    {
        InvalidState {
            reason: reason.into(),
        }
    }
    pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<InvalidState> {
        i_prot.read_struct_begin()?;
        let mut f_1: Option<String> = Some("".to_owned());
        loop {
            let field_ident = i_prot.read_field_begin()?;
            if field_ident.field_type == TType::Stop {
                break;
            }
            let field_id = field_id(&field_ident)?;
            match field_id {
                1 => {
                    let val = i_prot.read_string()?;
                    f_1 = Some(val);
                }
                _ => {
                    i_prot.skip(field_ident.field_type)?;
                }
            };
            i_prot.read_field_end()?;
        }
        i_prot.read_struct_end()?;
        let ret = InvalidState { reason: f_1 };
        Ok(ret)
    }
    pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
        let struct_ident = TStructIdentifier::new("InvalidState");
        o_prot.write_struct_begin(&struct_ident)?;
        if let Some(ref fld_var) = self.reason {
            o_prot.write_field_begin(&TFieldIdentifier::new("reason", TType::String, 1))?;
            o_prot.write_string(fld_var)?;
            o_prot.write_field_end()?;
            ()
        } else {
            ()
        }
        o_prot.write_field_stop()?;
        o_prot.write_struct_end()
    }
}

impl Default for InvalidState {
    fn default() -> Self {
        InvalidState {
            reason: Some("".to_owned()),
        }
    }
}

impl Error for InvalidState {
    fn description(&self) -> &str {
        "remote service threw InvalidState"
    }
}

impl From<InvalidState> for thrift::Error {
    fn from(e: InvalidState) -> Self {
        thrift::Error::User(Box::new(e))
    }
}

impl Display for InvalidState {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        self.description().fmt(f)
    }
}

//
// CraqService service client
//

/// Artillery CRAQ service.
pub trait TCraqServiceSyncClient {
    /// Reads a value with the desired consistency model.
    fn read(
        &mut self,
        model: CraqConsistencyModel,
        version_bound: Version,
    ) -> thrift::Result<CraqObject>;
    /// Writes a new value.
    fn write(&mut self, obj: CraqObject) -> thrift::Result<Version>;
    /// Performs a test-and-set operation. *
    fn test_and_set(
        &mut self,
        obj: CraqObject,
        expected_version: Version,
    ) -> thrift::Result<Version>;
    /// Writes a new value with the given version.
    fn write_versioned(&mut self, obj: CraqObject, version: Version) -> thrift::Result<()>;
    /// Returns the latest committed version.
    fn version_query(&mut self) -> thrift::Result<Version>;
}

pub trait TCraqServiceSyncClientMarker {}

pub struct CraqServiceSyncClient<IP, OP>
where
    IP: TInputProtocol,
    OP: TOutputProtocol,
{
    _i_prot: IP,
    _o_prot: OP,
    _sequence_number: i32,
}

impl<IP, OP> CraqServiceSyncClient<IP, OP>
where
    IP: TInputProtocol,
    OP: TOutputProtocol,
{
    pub fn new(input_protocol: IP, output_protocol: OP) -> CraqServiceSyncClient<IP, OP> {
        CraqServiceSyncClient {
            _i_prot: input_protocol,
            _o_prot: output_protocol,
            _sequence_number: 0,
        }
    }
}

impl<IP, OP> TThriftClient for CraqServiceSyncClient<IP, OP>
where
    IP: TInputProtocol,
    OP: TOutputProtocol,
{
    fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol {
        &mut self._i_prot
    }
    fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol {
        &mut self._o_prot
    }
    fn sequence_number(&self) -> i32 {
        self._sequence_number
    }
    fn increment_sequence_number(&mut self) -> i32 {
        self._sequence_number += 1;
        self._sequence_number
    }
}

impl<IP, OP> TCraqServiceSyncClientMarker for CraqServiceSyncClient<IP, OP>
where
    IP: TInputProtocol,
    OP: TOutputProtocol,
{
}

impl<C: TThriftClient + TCraqServiceSyncClientMarker> TCraqServiceSyncClient for C {
    fn read(
        &mut self,
        model: CraqConsistencyModel,
        version_bound: Version,
    ) -> thrift::Result<CraqObject> {
        ({
            self.increment_sequence_number();
            let message_ident =
                TMessageIdentifier::new("read", TMessageType::Call, self.sequence_number());
            let call_args = CraqServiceReadArgs {
                model: model,
                version_bound: version_bound,
            };
            self.o_prot_mut().write_message_begin(&message_ident)?;
            call_args.write_to_out_protocol(self.o_prot_mut())?;
            self.o_prot_mut().write_message_end()?;
            self.o_prot_mut().flush()
        })?;
        {
            let message_ident = self.i_prot_mut().read_message_begin()?;
            verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
            verify_expected_service_call("read", &message_ident.name)?;
            if message_ident.message_type == TMessageType::Exception {
                let remote_error =
                    thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
                self.i_prot_mut().read_message_end()?;
                return Err(thrift::Error::Application(remote_error));
            }
            verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
            let result = CraqServiceReadResult::read_from_in_protocol(self.i_prot_mut())?;
            self.i_prot_mut().read_message_end()?;
            result.ok_or()
        }
    }
    fn write(&mut self, obj: CraqObject) -> thrift::Result<Version> {
        ({
            self.increment_sequence_number();
            let message_ident =
                TMessageIdentifier::new("write", TMessageType::Call, self.sequence_number());
            let call_args = CraqServiceWriteArgs { obj: obj };
            self.o_prot_mut().write_message_begin(&message_ident)?;
            call_args.write_to_out_protocol(self.o_prot_mut())?;
            self.o_prot_mut().write_message_end()?;
            self.o_prot_mut().flush()
        })?;
        {
            let message_ident = self.i_prot_mut().read_message_begin()?;
            verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
            verify_expected_service_call("write", &message_ident.name)?;
            if message_ident.message_type == TMessageType::Exception {
                let remote_error =
                    thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
                self.i_prot_mut().read_message_end()?;
                return Err(thrift::Error::Application(remote_error));
            }
            verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
            let result = CraqServiceWriteResult::read_from_in_protocol(self.i_prot_mut())?;
            self.i_prot_mut().read_message_end()?;
            result.ok_or()
        }
    }
    fn test_and_set(
        &mut self,
        obj: CraqObject,
        expected_version: Version,
    ) -> thrift::Result<Version> {
        ({
            self.increment_sequence_number();
            let message_ident =
                TMessageIdentifier::new("testAndSet", TMessageType::Call, self.sequence_number());
            let call_args = CraqServiceTestAndSetArgs {
                obj: obj,
                expected_version: expected_version,
            };
            self.o_prot_mut().write_message_begin(&message_ident)?;
            call_args.write_to_out_protocol(self.o_prot_mut())?;
            self.o_prot_mut().write_message_end()?;
            self.o_prot_mut().flush()
        })?;
        {
            let message_ident = self.i_prot_mut().read_message_begin()?;
            verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
            verify_expected_service_call("testAndSet", &message_ident.name)?;
            if message_ident.message_type == TMessageType::Exception {
                let remote_error =
                    thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
                self.i_prot_mut().read_message_end()?;
                return Err(thrift::Error::Application(remote_error));
            }
            verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
            let result = CraqServiceTestAndSetResult::read_from_in_protocol(self.i_prot_mut())?;
            self.i_prot_mut().read_message_end()?;
            result.ok_or()
        }
    }
    fn write_versioned(&mut self, obj: CraqObject, version: Version) -> thrift::Result<()> {
        ({
            self.increment_sequence_number();
            let message_ident = TMessageIdentifier::new(
                "writeVersioned",
                TMessageType::Call,
                self.sequence_number(),
            );
            let call_args = CraqServiceWriteVersionedArgs {
                obj: obj,
                version: version,
            };
            self.o_prot_mut().write_message_begin(&message_ident)?;
            call_args.write_to_out_protocol(self.o_prot_mut())?;
            self.o_prot_mut().write_message_end()?;
            self.o_prot_mut().flush()
        })?;
        {
            let message_ident = self.i_prot_mut().read_message_begin()?;
            verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
            verify_expected_service_call("writeVersioned", &message_ident.name)?;
            if message_ident.message_type == TMessageType::Exception {
                let remote_error =
                    thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
                self.i_prot_mut().read_message_end()?;
                return Err(thrift::Error::Application(remote_error));
            }
            verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
            let result = CraqServiceWriteVersionedResult::read_from_in_protocol(self.i_prot_mut())?;
            self.i_prot_mut().read_message_end()?;
            result.ok_or()
        }
    }
    fn version_query(&mut self) -> thrift::Result<Version> {
        ({
            self.increment_sequence_number();
            let message_ident =
                TMessageIdentifier::new("versionQuery", TMessageType::Call, self.sequence_number());
            let call_args = CraqServiceVersionQueryArgs {};
            self.o_prot_mut().write_message_begin(&message_ident)?;
            call_args.write_to_out_protocol(self.o_prot_mut())?;
            self.o_prot_mut().write_message_end()?;
            self.o_prot_mut().flush()
        })?;
        {
            let message_ident = self.i_prot_mut().read_message_begin()?;
            verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
            verify_expected_service_call("versionQuery", &message_ident.name)?;
            if message_ident.message_type == TMessageType::Exception {
                let remote_error =
                    thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
                self.i_prot_mut().read_message_end()?;
                return Err(thrift::Error::Application(remote_error));
            }
            verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
            let result = CraqServiceVersionQueryResult::read_from_in_protocol(self.i_prot_mut())?;
            self.i_prot_mut().read_message_end()?;
            result.ok_or()
        }
    }
}

//
// CraqService service processor
//

/// Artillery CRAQ service.
pub trait CraqServiceSyncHandler {
    /// Reads a value with the desired consistency model.
    fn handle_read(
        &self,
        model: CraqConsistencyModel,
        version_bound: Version,
    ) -> thrift::Result<CraqObject>;
    /// Writes a new value.
    fn handle_write(&self, obj: CraqObject) -> thrift::Result<Version>;
    /// Performs a test-and-set operation. *
    fn handle_test_and_set(
        &self,
        obj: CraqObject,
        expected_version: Version,
    ) -> thrift::Result<Version>;
    /// Writes a new value with the given version.
    fn handle_write_versioned(&self, obj: CraqObject, version: Version) -> thrift::Result<()>;
    /// Returns the latest committed version.
    fn handle_version_query(&self) -> thrift::Result<Version>;
}

pub struct CraqServiceSyncProcessor<H: CraqServiceSyncHandler> {
    handler: H,
}

impl<H: CraqServiceSyncHandler> CraqServiceSyncProcessor<H> {
    pub fn new(handler: H) -> CraqServiceSyncProcessor<H> {
        CraqServiceSyncProcessor { handler }
    }
    fn process_read(
        &self,
        incoming_sequence_number: i32,
        i_prot: &mut dyn TInputProtocol,
        o_prot: &mut dyn TOutputProtocol,
    ) -> thrift::Result<()> {
        TCraqServiceProcessFunctions::process_read(
            &self.handler,
            incoming_sequence_number,
            i_prot,
            o_prot,
        )
    }
    fn process_write(
        &self,
        incoming_sequence_number: i32,
        i_prot: &mut dyn TInputProtocol,
        o_prot: &mut dyn TOutputProtocol,
    ) -> thrift::Result<()> {
        TCraqServiceProcessFunctions::process_write(
            &self.handler,
            incoming_sequence_number,
            i_prot,
            o_prot,
        )
    }
    fn process_test_and_set(
        &self,
        incoming_sequence_number: i32,
        i_prot: &mut dyn TInputProtocol,
        o_prot: &mut dyn TOutputProtocol,
    ) -> thrift::Result<()> {
        TCraqServiceProcessFunctions::process_test_and_set(
            &self.handler,
            incoming_sequence_number,
            i_prot,
            o_prot,
        )
    }
    fn process_write_versioned(
        &self,
        incoming_sequence_number: i32,
        i_prot: &mut dyn TInputProtocol,
        o_prot: &mut dyn TOutputProtocol,
    ) -> thrift::Result<()> {
        TCraqServiceProcessFunctions::process_write_versioned(
            &self.handler,
            incoming_sequence_number,
            i_prot,
            o_prot,
        )
    }
    fn process_version_query(
        &self,
        incoming_sequence_number: i32,
        i_prot: &mut dyn TInputProtocol,
        o_prot: &mut dyn TOutputProtocol,
    ) -> thrift::Result<()> {
        TCraqServiceProcessFunctions::process_version_query(
            &self.handler,
            incoming_sequence_number,
            i_prot,
            o_prot,
        )
    }
}

pub struct TCraqServiceProcessFunctions;

impl TCraqServiceProcessFunctions {
    pub fn process_read<H: CraqServiceSyncHandler>(
        handler: &H,
        incoming_sequence_number: i32,
        i_prot: &mut dyn TInputProtocol,
        o_prot: &mut dyn TOutputProtocol,
    ) -> thrift::Result<()> {
        let args = CraqServiceReadArgs::read_from_in_protocol(i_prot)?;
        match handler.handle_read(args.model, args.version_bound) {
            Ok(handler_return) => {
                let message_ident =
                    TMessageIdentifier::new("read", TMessageType::Reply, incoming_sequence_number);
                o_prot.write_message_begin(&message_ident)?;
                let ret = CraqServiceReadResult {
                    result_value: Some(handler_return),
                };
                ret.write_to_out_protocol(o_prot)?;
                o_prot.write_message_end()?;
                o_prot.flush()
            }
            Err(e) => match e {
                thrift::Error::Application(app_err) => {
                    let message_ident = TMessageIdentifier::new(
                        "read",
                        TMessageType::Exception,
                        incoming_sequence_number,
                    );
                    o_prot.write_message_begin(&message_ident)?;
                    thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
                    o_prot.write_message_end()?;
                    o_prot.flush()
                }
                _ => {
                    let ret_err =
                        ApplicationError::new(ApplicationErrorKind::Unknown, e.description());
                    let message_ident = TMessageIdentifier::new(
                        "read",
                        TMessageType::Exception,
                        incoming_sequence_number,
                    );
                    o_prot.write_message_begin(&message_ident)?;
                    thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
                    o_prot.write_message_end()?;
                    o_prot.flush()
                }
            },
        }
    }
    pub fn process_write<H: CraqServiceSyncHandler>(
        handler: &H,
        incoming_sequence_number: i32,
        i_prot: &mut dyn TInputProtocol,
        o_prot: &mut dyn TOutputProtocol,
    ) -> thrift::Result<()> {
        let args = CraqServiceWriteArgs::read_from_in_protocol(i_prot)?;
        match handler.handle_write(args.obj) {
            Ok(handler_return) => {
                let message_ident =
                    TMessageIdentifier::new("write", TMessageType::Reply, incoming_sequence_number);
                o_prot.write_message_begin(&message_ident)?;
                let ret = CraqServiceWriteResult {
                    result_value: Some(handler_return),
                };
                ret.write_to_out_protocol(o_prot)?;
                o_prot.write_message_end()?;
                o_prot.flush()
            }
            Err(e) => match e {
                thrift::Error::Application(app_err) => {
                    let message_ident = TMessageIdentifier::new(
                        "write",
                        TMessageType::Exception,
                        incoming_sequence_number,
                    );
                    o_prot.write_message_begin(&message_ident)?;
                    thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
                    o_prot.write_message_end()?;
                    o_prot.flush()
                }
                _ => {
                    let ret_err =
                        ApplicationError::new(ApplicationErrorKind::Unknown, e.description());
                    let message_ident = TMessageIdentifier::new(
                        "write",
                        TMessageType::Exception,
                        incoming_sequence_number,
                    );
                    o_prot.write_message_begin(&message_ident)?;
                    thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
                    o_prot.write_message_end()?;
                    o_prot.flush()
                }
            },
        }
    }
    pub fn process_test_and_set<H: CraqServiceSyncHandler>(
        handler: &H,
        incoming_sequence_number: i32,
        i_prot: &mut dyn TInputProtocol,
        o_prot: &mut dyn TOutputProtocol,
    ) -> thrift::Result<()> {
        let args = CraqServiceTestAndSetArgs::read_from_in_protocol(i_prot)?;
        match handler.handle_test_and_set(args.obj, args.expected_version) {
            Ok(handler_return) => {
                let message_ident = TMessageIdentifier::new(
                    "testAndSet",
                    TMessageType::Reply,
                    incoming_sequence_number,
                );
                o_prot.write_message_begin(&message_ident)?;
                let ret = CraqServiceTestAndSetResult {
                    result_value: Some(handler_return),
                };
                ret.write_to_out_protocol(o_prot)?;
                o_prot.write_message_end()?;
                o_prot.flush()
            }
            Err(e) => match e {
                thrift::Error::Application(app_err) => {
                    let message_ident = TMessageIdentifier::new(
                        "testAndSet",
                        TMessageType::Exception,
                        incoming_sequence_number,
                    );
                    o_prot.write_message_begin(&message_ident)?;
                    thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
                    o_prot.write_message_end()?;
                    o_prot.flush()
                }
                _ => {
                    let ret_err =
                        ApplicationError::new(ApplicationErrorKind::Unknown, e.description());
                    let message_ident = TMessageIdentifier::new(
                        "testAndSet",
                        TMessageType::Exception,
                        incoming_sequence_number,
                    );
                    o_prot.write_message_begin(&message_ident)?;
                    thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
                    o_prot.write_message_end()?;
                    o_prot.flush()
                }
            },
        }
    }
    pub fn process_write_versioned<H: CraqServiceSyncHandler>(
        handler: &H,
        incoming_sequence_number: i32,
        i_prot: &mut dyn TInputProtocol,
        o_prot: &mut dyn TOutputProtocol,
    ) -> thrift::Result<()> {
        let args = CraqServiceWriteVersionedArgs::read_from_in_protocol(i_prot)?;
        match handler.handle_write_versioned(args.obj, args.version) {
            Ok(_) => {
                let message_ident = TMessageIdentifier::new(
                    "writeVersioned",
                    TMessageType::Reply,
                    incoming_sequence_number,
                );
                o_prot.write_message_begin(&message_ident)?;
                let ret = CraqServiceWriteVersionedResult {};
                ret.write_to_out_protocol(o_prot)?;
                o_prot.write_message_end()?;
                o_prot.flush()
            }
            Err(e) => match e {
                thrift::Error::Application(app_err) => {
                    let message_ident = TMessageIdentifier::new(
                        "writeVersioned",
                        TMessageType::Exception,
                        incoming_sequence_number,
                    );
                    o_prot.write_message_begin(&message_ident)?;
                    thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
                    o_prot.write_message_end()?;
                    o_prot.flush()
                }
                _ => {
                    let ret_err =
                        ApplicationError::new(ApplicationErrorKind::Unknown, e.description());
                    let message_ident = TMessageIdentifier::new(
                        "writeVersioned",
                        TMessageType::Exception,
                        incoming_sequence_number,
                    );
                    o_prot.write_message_begin(&message_ident)?;
                    thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
                    o_prot.write_message_end()?;
                    o_prot.flush()
                }
            },
        }
    }
    pub fn process_version_query<H: CraqServiceSyncHandler>(
        handler: &H,
        incoming_sequence_number: i32,
        i_prot: &mut dyn TInputProtocol,
        o_prot: &mut dyn TOutputProtocol,
    ) -> thrift::Result<()> {
        let _ = CraqServiceVersionQueryArgs::read_from_in_protocol(i_prot)?;
        match handler.handle_version_query() {
            Ok(handler_return) => {
                let message_ident = TMessageIdentifier::new(
                    "versionQuery",
                    TMessageType::Reply,
                    incoming_sequence_number,
                );
                o_prot.write_message_begin(&message_ident)?;
                let ret = CraqServiceVersionQueryResult {
                    result_value: Some(handler_return),
                };
                ret.write_to_out_protocol(o_prot)?;
                o_prot.write_message_end()?;
                o_prot.flush()
            }
            Err(e) => match e {
                thrift::Error::Application(app_err) => {
                    let message_ident = TMessageIdentifier::new(
                        "versionQuery",
                        TMessageType::Exception,
                        incoming_sequence_number,
                    );
                    o_prot.write_message_begin(&message_ident)?;
                    thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
                    o_prot.write_message_end()?;
                    o_prot.flush()
                }
                _ => {
                    let ret_err =
                        ApplicationError::new(ApplicationErrorKind::Unknown, e.description());
                    let message_ident = TMessageIdentifier::new(
                        "versionQuery",
                        TMessageType::Exception,
                        incoming_sequence_number,
                    );
                    o_prot.write_message_begin(&message_ident)?;
                    thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
                    o_prot.write_message_end()?;
                    o_prot.flush()
                }
            },
        }
    }
}

impl<H: CraqServiceSyncHandler> TProcessor for CraqServiceSyncProcessor<H> {
    fn process(
        &self,
        i_prot: &mut dyn TInputProtocol,
        o_prot: &mut dyn TOutputProtocol,
    ) -> thrift::Result<()> {
        let message_ident = i_prot.read_message_begin()?;
        let res = match &*message_ident.name {
            "read" => self.process_read(message_ident.sequence_number, i_prot, o_prot),
            "write" => self.process_write(message_ident.sequence_number, i_prot, o_prot),
            "testAndSet" => {
                self.process_test_and_set(message_ident.sequence_number, i_prot, o_prot)
            }
            "writeVersioned" => {
                self.process_write_versioned(message_ident.sequence_number, i_prot, o_prot)
            }
            "versionQuery" => {
                self.process_version_query(message_ident.sequence_number, i_prot, o_prot)
            }
            method => Err(thrift::Error::Application(ApplicationError::new(
                ApplicationErrorKind::UnknownMethod,
                format!("unknown method {}", method),
            ))),
        };
        thrift::server::handle_process_result(&message_ident, res, o_prot)
    }
}

//
// CraqServiceReadArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct CraqServiceReadArgs {
    model: CraqConsistencyModel,
    version_bound: Version,
}

impl CraqServiceReadArgs {
    fn read_from_in_protocol(
        i_prot: &mut dyn TInputProtocol,
    ) -> thrift::Result<CraqServiceReadArgs> {
        i_prot.read_struct_begin()?;
        let mut f_1: Option<CraqConsistencyModel> = None;
        let mut f_2: Option<Version> = None;
        loop {
            let field_ident = i_prot.read_field_begin()?;
            if field_ident.field_type == TType::Stop {
                break;
            }
            let field_id = field_id(&field_ident)?;
            match field_id {
                1 => {
                    let val = CraqConsistencyModel::read_from_in_protocol(i_prot)?;
                    f_1 = Some(val);
                }
                2 => {
                    let val = i_prot.read_i64()?;
                    f_2 = Some(val);
                }
                _ => {
                    i_prot.skip(field_ident.field_type)?;
                }
            };
            i_prot.read_field_end()?;
        }
        i_prot.read_struct_end()?;
        verify_required_field_exists("CraqServiceReadArgs.model", &f_1)?;
        verify_required_field_exists("CraqServiceReadArgs.version_bound", &f_2)?;
        let ret = CraqServiceReadArgs {
            model: f_1
                .expect("auto-generated code should have checked for presence of required fields"),
            version_bound: f_2
                .expect("auto-generated code should have checked for presence of required fields"),
        };
        Ok(ret)
    }
    fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
        let struct_ident = TStructIdentifier::new("read_args");
        o_prot.write_struct_begin(&struct_ident)?;
        o_prot.write_field_begin(&TFieldIdentifier::new("model", TType::I32, 1))?;
        self.model.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
        o_prot.write_field_begin(&TFieldIdentifier::new("versionBound", TType::I64, 2))?;
        o_prot.write_i64(self.version_bound)?;
        o_prot.write_field_end()?;
        o_prot.write_field_stop()?;
        o_prot.write_struct_end()
    }
}

//
// CraqServiceReadResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct CraqServiceReadResult {
    result_value: Option<CraqObject>,
}

impl CraqServiceReadResult {
    fn read_from_in_protocol(
        i_prot: &mut dyn TInputProtocol,
    ) -> thrift::Result<CraqServiceReadResult> {
        i_prot.read_struct_begin()?;
        let mut f_0: Option<CraqObject> = None;
        loop {
            let field_ident = i_prot.read_field_begin()?;
            if field_ident.field_type == TType::Stop {
                break;
            }
            let field_id = field_id(&field_ident)?;
            match field_id {
                0 => {
                    let val = CraqObject::read_from_in_protocol(i_prot)?;
                    f_0 = Some(val);
                }
                _ => {
                    i_prot.skip(field_ident.field_type)?;
                }
            };
            i_prot.read_field_end()?;
        }
        i_prot.read_struct_end()?;
        let ret = CraqServiceReadResult { result_value: f_0 };
        Ok(ret)
    }
    fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
        let struct_ident = TStructIdentifier::new("CraqServiceReadResult");
        o_prot.write_struct_begin(&struct_ident)?;
        if let Some(ref fld_var) = self.result_value {
            o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
            fld_var.write_to_out_protocol(o_prot)?;
            o_prot.write_field_end()?;
            ()
        } else {
            ()
        }
        o_prot.write_field_stop()?;
        o_prot.write_struct_end()
    }
    fn ok_or(self) -> thrift::Result<CraqObject> {
        if self.result_value.is_some() {
            Ok(self.result_value.unwrap())
        } else {
            Err(thrift::Error::Application(ApplicationError::new(
                ApplicationErrorKind::MissingResult,
                "no result received for CraqServiceRead",
            )))
        }
    }
}

//
// CraqServiceWriteArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct CraqServiceWriteArgs {
    obj: CraqObject,
}

impl CraqServiceWriteArgs {
    fn read_from_in_protocol(
        i_prot: &mut dyn TInputProtocol,
    ) -> thrift::Result<CraqServiceWriteArgs> {
        i_prot.read_struct_begin()?;
        let mut f_1: Option<CraqObject> = None;
        loop {
            let field_ident = i_prot.read_field_begin()?;
            if field_ident.field_type == TType::Stop {
                break;
            }
            let field_id = field_id(&field_ident)?;
            match field_id {
                1 => {
                    let val = CraqObject::read_from_in_protocol(i_prot)?;
                    f_1 = Some(val);
                }
                _ => {
                    i_prot.skip(field_ident.field_type)?;
                }
            };
            i_prot.read_field_end()?;
        }
        i_prot.read_struct_end()?;
        verify_required_field_exists("CraqServiceWriteArgs.obj", &f_1)?;
        let ret = CraqServiceWriteArgs {
            obj: f_1
                .expect("auto-generated code should have checked for presence of required fields"),
        };
        Ok(ret)
    }
    fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
        let struct_ident = TStructIdentifier::new("write_args");
        o_prot.write_struct_begin(&struct_ident)?;
        o_prot.write_field_begin(&TFieldIdentifier::new("obj", TType::Struct, 1))?;
        self.obj.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
        o_prot.write_field_stop()?;
        o_prot.write_struct_end()
    }
}

//
// CraqServiceWriteResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct CraqServiceWriteResult {
    result_value: Option<Version>,
}

impl CraqServiceWriteResult {
    fn read_from_in_protocol(
        i_prot: &mut dyn TInputProtocol,
    ) -> thrift::Result<CraqServiceWriteResult> {
        i_prot.read_struct_begin()?;
        let mut f_0: Option<Version> = None;
        loop {
            let field_ident = i_prot.read_field_begin()?;
            if field_ident.field_type == TType::Stop {
                break;
            }
            let field_id = field_id(&field_ident)?;
            match field_id {
                0 => {
                    let val = i_prot.read_i64()?;
                    f_0 = Some(val);
                }
                _ => {
                    i_prot.skip(field_ident.field_type)?;
                }
            };
            i_prot.read_field_end()?;
        }
        i_prot.read_struct_end()?;
        let ret = CraqServiceWriteResult { result_value: f_0 };
        Ok(ret)
    }
    fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
        let struct_ident = TStructIdentifier::new("CraqServiceWriteResult");
        o_prot.write_struct_begin(&struct_ident)?;
        if let Some(fld_var) = self.result_value {
            o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I64, 0))?;
            o_prot.write_i64(fld_var)?;
            o_prot.write_field_end()?;
            ()
        } else {
            ()
        }
        o_prot.write_field_stop()?;
        o_prot.write_struct_end()
    }
    fn ok_or(self) -> thrift::Result<Version> {
        if self.result_value.is_some() {
            Ok(self.result_value.unwrap())
        } else {
            Err(thrift::Error::Application(ApplicationError::new(
                ApplicationErrorKind::MissingResult,
                "no result received for CraqServiceWrite",
            )))
        }
    }
}

//
// CraqServiceTestAndSetArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct CraqServiceTestAndSetArgs {
    obj: CraqObject,
    expected_version: Version,
}

impl CraqServiceTestAndSetArgs {
    fn read_from_in_protocol(
        i_prot: &mut dyn TInputProtocol,
    ) -> thrift::Result<CraqServiceTestAndSetArgs> {
        i_prot.read_struct_begin()?;
        let mut f_1: Option<CraqObject> = None;
        let mut f_2: Option<Version> = None;
        loop {
            let field_ident = i_prot.read_field_begin()?;
            if field_ident.field_type == TType::Stop {
                break;
            }
            let field_id = field_id(&field_ident)?;
            match field_id {
                1 => {
                    let val = CraqObject::read_from_in_protocol(i_prot)?;
                    f_1 = Some(val);
                }
                2 => {
                    let val = i_prot.read_i64()?;
                    f_2 = Some(val);
                }
                _ => {
                    i_prot.skip(field_ident.field_type)?;
                }
            };
            i_prot.read_field_end()?;
        }
        i_prot.read_struct_end()?;
        verify_required_field_exists("CraqServiceTestAndSetArgs.obj", &f_1)?;
        verify_required_field_exists("CraqServiceTestAndSetArgs.expected_version", &f_2)?;
        let ret = CraqServiceTestAndSetArgs {
            obj: f_1
                .expect("auto-generated code should have checked for presence of required fields"),
            expected_version: f_2
                .expect("auto-generated code should have checked for presence of required fields"),
        };
        Ok(ret)
    }
    fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
        let struct_ident = TStructIdentifier::new("testAndSet_args");
        o_prot.write_struct_begin(&struct_ident)?;
        o_prot.write_field_begin(&TFieldIdentifier::new("obj", TType::Struct, 1))?;
        self.obj.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
        o_prot.write_field_begin(&TFieldIdentifier::new("expectedVersion", TType::I64, 2))?;
        o_prot.write_i64(self.expected_version)?;
        o_prot.write_field_end()?;
        o_prot.write_field_stop()?;
        o_prot.write_struct_end()
    }
}

//
// CraqServiceTestAndSetResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct CraqServiceTestAndSetResult {
    result_value: Option<Version>,
}

impl CraqServiceTestAndSetResult {
    fn read_from_in_protocol(
        i_prot: &mut dyn TInputProtocol,
    ) -> thrift::Result<CraqServiceTestAndSetResult> {
        i_prot.read_struct_begin()?;
        let mut f_0: Option<Version> = None;
        loop {
            let field_ident = i_prot.read_field_begin()?;
            if field_ident.field_type == TType::Stop {
                break;
            }
            let field_id = field_id(&field_ident)?;
            match field_id {
                0 => {
                    let val = i_prot.read_i64()?;
                    f_0 = Some(val);
                }
                _ => {
                    i_prot.skip(field_ident.field_type)?;
                }
            };
            i_prot.read_field_end()?;
        }
        i_prot.read_struct_end()?;
        let ret = CraqServiceTestAndSetResult { result_value: f_0 };
        Ok(ret)
    }
    fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
        let struct_ident = TStructIdentifier::new("CraqServiceTestAndSetResult");
        o_prot.write_struct_begin(&struct_ident)?;
        if let Some(fld_var) = self.result_value {
            o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I64, 0))?;
            o_prot.write_i64(fld_var)?;
            o_prot.write_field_end()?;
            ()
        } else {
            ()
        }
        o_prot.write_field_stop()?;
        o_prot.write_struct_end()
    }
    fn ok_or(self) -> thrift::Result<Version> {
        if self.result_value.is_some() {
            Ok(self.result_value.unwrap())
        } else {
            Err(thrift::Error::Application(ApplicationError::new(
                ApplicationErrorKind::MissingResult,
                "no result received for CraqServiceTestAndSet",
            )))
        }
    }
}

//
// CraqServiceWriteVersionedArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct CraqServiceWriteVersionedArgs {
    obj: CraqObject,
    version: Version,
}

impl CraqServiceWriteVersionedArgs {
    fn read_from_in_protocol(
        i_prot: &mut dyn TInputProtocol,
    ) -> thrift::Result<CraqServiceWriteVersionedArgs> {
        i_prot.read_struct_begin()?;
        let mut f_1: Option<CraqObject> = None;
        let mut f_2: Option<Version> = None;
        loop {
            let field_ident = i_prot.read_field_begin()?;
            if field_ident.field_type == TType::Stop {
                break;
            }
            let field_id = field_id(&field_ident)?;
            match field_id {
                1 => {
                    let val = CraqObject::read_from_in_protocol(i_prot)?;
                    f_1 = Some(val);
                }
                2 => {
                    let val = i_prot.read_i64()?;
                    f_2 = Some(val);
                }
                _ => {
                    i_prot.skip(field_ident.field_type)?;
                }
            };
            i_prot.read_field_end()?;
        }
        i_prot.read_struct_end()?;
        verify_required_field_exists("CraqServiceWriteVersionedArgs.obj", &f_1)?;
        verify_required_field_exists("CraqServiceWriteVersionedArgs.version", &f_2)?;
        let ret = CraqServiceWriteVersionedArgs {
            obj: f_1
                .expect("auto-generated code should have checked for presence of required fields"),
            version: f_2
                .expect("auto-generated code should have checked for presence of required fields"),
        };
        Ok(ret)
    }
    fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
        let struct_ident = TStructIdentifier::new("writeVersioned_args");
        o_prot.write_struct_begin(&struct_ident)?;
        o_prot.write_field_begin(&TFieldIdentifier::new("obj", TType::Struct, 1))?;
        self.obj.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
        o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::I64, 2))?;
        o_prot.write_i64(self.version)?;
        o_prot.write_field_end()?;
        o_prot.write_field_stop()?;
        o_prot.write_struct_end()
    }
}

//
// CraqServiceWriteVersionedResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct CraqServiceWriteVersionedResult {}

impl CraqServiceWriteVersionedResult {
    fn read_from_in_protocol(
        i_prot: &mut dyn TInputProtocol,
    ) -> thrift::Result<CraqServiceWriteVersionedResult> {
        i_prot.read_struct_begin()?;
        loop {
            let field_ident = i_prot.read_field_begin()?;
            if field_ident.field_type == TType::Stop {
                break;
            }
            let field_id = field_id(&field_ident)?;
            match field_id {
                _ => {
                    i_prot.skip(field_ident.field_type)?;
                }
            };
            i_prot.read_field_end()?;
        }
        i_prot.read_struct_end()?;
        let ret = CraqServiceWriteVersionedResult {};
        Ok(ret)
    }
    fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
        let struct_ident = TStructIdentifier::new("CraqServiceWriteVersionedResult");
        o_prot.write_struct_begin(&struct_ident)?;
        o_prot.write_field_stop()?;
        o_prot.write_struct_end()
    }
    fn ok_or(self) -> thrift::Result<()> {
        Ok(())
    }
}

//
// CraqServiceVersionQueryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct CraqServiceVersionQueryArgs {}

impl CraqServiceVersionQueryArgs {
    fn read_from_in_protocol(
        i_prot: &mut dyn TInputProtocol,
    ) -> thrift::Result<CraqServiceVersionQueryArgs> {
        i_prot.read_struct_begin()?;
        loop {
            let field_ident = i_prot.read_field_begin()?;
            if field_ident.field_type == TType::Stop {
                break;
            }
            let field_id = field_id(&field_ident)?;
            match field_id {
                _ => {
                    i_prot.skip(field_ident.field_type)?;
                }
            };
            i_prot.read_field_end()?;
        }
        i_prot.read_struct_end()?;
        let ret = CraqServiceVersionQueryArgs {};
        Ok(ret)
    }
    fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
        let struct_ident = TStructIdentifier::new("versionQuery_args");
        o_prot.write_struct_begin(&struct_ident)?;
        o_prot.write_field_stop()?;
        o_prot.write_struct_end()
    }
}

//
// CraqServiceVersionQueryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct CraqServiceVersionQueryResult {
    result_value: Option<Version>,
}

impl CraqServiceVersionQueryResult {
    fn read_from_in_protocol(
        i_prot: &mut dyn TInputProtocol,
    ) -> thrift::Result<CraqServiceVersionQueryResult> {
        i_prot.read_struct_begin()?;
        let mut f_0: Option<Version> = None;
        loop {
            let field_ident = i_prot.read_field_begin()?;
            if field_ident.field_type == TType::Stop {
                break;
            }
            let field_id = field_id(&field_ident)?;
            match field_id {
                0 => {
                    let val = i_prot.read_i64()?;
                    f_0 = Some(val);
                }
                _ => {
                    i_prot.skip(field_ident.field_type)?;
                }
            };
            i_prot.read_field_end()?;
        }
        i_prot.read_struct_end()?;
        let ret = CraqServiceVersionQueryResult { result_value: f_0 };
        Ok(ret)
    }
    fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
        let struct_ident = TStructIdentifier::new("CraqServiceVersionQueryResult");
        o_prot.write_struct_begin(&struct_ident)?;
        if let Some(fld_var) = self.result_value {
            o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I64, 0))?;
            o_prot.write_i64(fld_var)?;
            o_prot.write_field_end()?;
            ()
        } else {
            ()
        }
        o_prot.write_field_stop()?;
        o_prot.write_struct_end()
    }
    fn ok_or(self) -> thrift::Result<Version> {
        if self.result_value.is_some() {
            Ok(self.result_value.unwrap())
        } else {
            Err(thrift::Error::Application(ApplicationError::new(
                ApplicationErrorKind::MissingResult,
                "no result received for CraqServiceVersionQuery",
            )))
        }
    }
}
